1. 函数声明和函数表达式有什么区别
函数声明：函数声明就是使用 function 关键字来声明一个函数，利用function声明的函数会进行声明前置，因此不管调用函数的位置不管是在声明前面还是后面都是可行的。

	sum(3,6);   // 虽然函数声明在后面，但可以成功调用，输出9
	function sum(a,b){
		console.log(a+b); }
函数表达式：本质上是个表达式，即创建一个匿名函数，并赋值给一个变量,使用函数表达式 声明必须放在调用前面。

	sayhello()    //  报错
	var sayhello = function(){
		console.log('hello')
	}
	sayhello()    //  正确输出 hello
2. 什么是变量的声明前置？什么是函数的声明前置
变量提升：JS自动把var声明的变量提到最前面，先赋值为undefined，再按顺序执行语句
函数声明前置：JS自动把function声明的函数提到前面，因此调用函数时不需要考虑函数调用与声明的位置关系
3. arguments 是什么
argument是类数组对象，每个函数中都存在argument对象，argument并不是一个真正的数组，所以不具备除length属性之外的属性，这个对象维护着所有传入该函数的参数列表，通过arguments[1、2、3]等...可以获取到相应的传入参数

4. 函数的"重载"怎样实现
重载是函数具有相同的名字，根据传入的参数不同，执行不同操作。在js中没有类似其他语言的重载，因为同名函数会被覆盖。但是js可以通过在函数内部对传入参数进行判断来达到重载的目的。

function doAdd() {
  if(arguments.length == 1) {
    alert(arguments[0] + 5);
  } else if(arguments.length == 2) {
    alert(arguments[0] + arguments[1]);
  }
}
doAdd(10);        //输出 "15"
doAdd(40, 20);    //输出 "60"
5. 立即执行函数表达式是什么？有什么作用
立即执行函数表达式，首先它是一个表达式，而不是一个声明函数。其次，因为是表达式，所以可以用(), +, !, -等运算符来触发。然后，这种函数会被**立即执行**，而不是像声明函数一样，需要用 doSomthing()这种写法来执行。使用立即执行的函数表达式可以起到隔离作用域的作用。

6. 求n!，用递归来实现
递归的思想：是指在函数在定义中自己调用自己
一个比喻帮助理解：我们查词典的过程就是递归，为了解释一个词，需要使用更多的词。当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。
类推：n的阶乘，就是n乘(n-1)的阶乘，一直顺推到1的阶乘是1，作为终止条件。再逆推2的阶乘是2x(1的阶乘)),3的阶乘是3x(2的阶乘)，4的阶乘是4x(3的阶乘)......

    function factor(n){
    if (n === 1) { return 1 }
    return n * factor(n-1);
	}
   console.log(factor(4));  //输出24；
7 . 以下代码输出什么？
function getInfo(name, age, sex){
		console.log('name:',name);
		console.log('age:', age);
		console.log('sex:', sex);
		console.log(arguments);  //  按顺序输出所有传入参数
		arguments[0] = 'valley';
		console.log('name:', name);
	}
getInfo ('饥人谷', 2, '男'); // name:饥人谷 , age:2 , sex:男 ,  ["饥人谷", 2, "男"] ,  name:valley
getInfo ('小谷', 3); //name: 小谷 , age:3 , sex:undefined,  ["小谷", 3] , name:valley
getInfo ('男');// name: 男, age:undefined, sex:undefined, ["男"] , name:valley
8 . 写一个函数，返回参数的平方和？
   function sumOfSquares(){
   	var result=0;
	  	for (var i=0;i<arguments.length;i++){
	  		result = result+Math.pow(arguments[i],2);
	  } 
        return result;
   }
   var result = sumOfSquares(2,3,4)
   var result2 = sumOfSquares(1,3)
   console.log(result)  //29
   console.log(result2)  //10
9 . 如下代码的输出？为什么
	console.log(a);    //undefined 因为var变量声明前置，a一开始就被赋值为undefined
	var a = 1;
	console.log(b);  //报错 ，b未声明就使用
10. 如下代码的输出？为什么
	sayName('world');   //hello world ,因为function声明的函数前置，随意位置都可调用函数
	sayAge(10);  // 报错，因为函数表达式声明没有放在调用前
	function sayName(name){
		console.log('hello ', name);
	}
	var sayAge = function(age){
		console.log(age);
	};
11. 如下代码输出什么? 写出作用域链查找过程伪代码
var x = 10
bar()     //  输出10
function foo() {
  console.log(x)
}
function bar(){
  var x = 30
  foo()
}
/*变量和函数声明前置，得到全局的活动对象
globalContext = {
  AO: {
	    x: 10
	    foo: function
	    bar: function  }
  Scope: null
}
执行bar时，直接进入函数bar,bar函数内部自己声明了一个a并赋值为30，接着执行foo(),进入函数foo后，它内部并没有新定义的a,只有往上层找，也就找到了globalContext里的a。也就是说foo和bar是同级的，参数不会相互影响。
*/
12. 如下代码输出什么? 写出作用域链查找过程伪代码
var x = 10;
bar()  //输出30
function bar(){
  var x = 30;
  function foo(){
    console.log(x) 
  }
  foo();
}	
/*
执行bar()，直接进入bar函数，bar函数内部的活动对象
barContext = {
    AO: {
         x: 30
         foo :function }
    Scope: bar.[[scope]] //globalContext.AO(即x:1, bar:function)
}
bar内部新声明了一个X并赋值为30，当执行foo时，其内部并没有x,往上层找到barContext ，找到X=30,输出30
*/
13. 以下代码输出什么? 写出作用域链的查找过程伪代码
var x = 10;
bar()    //输出30
function bar(){
  var x = 30;
  (function (){
    console.log(x)  //与12同理，只不过该处为立即执行的函数表达式，未声明新的x变量，往上级找到bar声明的 x,输出30；
  })()
}
14. 以下代码输出什么？ 写出作用域链查找过程伪代码
var a = 1;   
function fn(){
  console.log(a)   //undefined ,函数内部变量提升，此时fn_a还未赋值，默认值为undefined
  var a = 5  
  console.log(a)  // 5 ,上条语句将fn_a赋值为5
  a++         //fn_a+1 = 6 
  var a        //fn_a已经存在，再次声明是没用的
  fn3() // 1  ，进入到fn3,fn3内部没有声明a，往上层找到global_a为1,
  fn2() // 6   ，进入到fn2,fn2内部没有声明a，往上层找到fn_a，输出6
  console.log(a)  // 20，  上条语句调用了f2(),f2将fn_a，赋值为20，此时输出20

  function fn2(){
    console.log(a)
    a = 20   //fn2内部没有声明a，往上层找到fn_a，赋值为20
  }
}

function fn3(){
  console.log(a) 
  a = 200  //fn3内部没有声明a，往上层找到global_a，赋值为200
}

fn()   // undefined 5 1 6 20 
console.log(a)   //200   输出global_a,由于之前调用了fn3(),fn3已经将global_a赋值为200，此时输出200
