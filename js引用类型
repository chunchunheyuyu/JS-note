1 引用类型有哪些？非引用类型有哪些2.如下代码输出什么？为什么
引用类型包含：对象、数组、函数、正则，这几种类型的数据都是保存在堆内存当中，栈内存当中存储的只是其堆内存的地址。基本类型值包含：数值、布尔值、null和undefined，这几种内存保存在堆内存当中，是简单的数据段。

var obj1 = {a:1, b:2};
var obj2 = {a:1, b:2};
console.log(obj1 == obj2);// false  ，因为 == 是判断符合，obj1 obj2 实际上是两个不同的对象，存放在堆内存不同的位置当中，也就是说他们的地址不同
console.log(obj1 = obj2);// Object {a: 1, b: 2}， = 是赋值符合，也就是说obj2 将自己赋值给obj1,两个对象的地址一致了，也就是说 此时 obj1就是obj2了。
console.log(obj1 == obj2);.// true,因为地址相同了，指向同一个堆内存内存储的对象。
3 如下代码输出什么? 为什么
var a = 1
var b = 2
var c = { name: '饥人谷', age: 2 }
var d = [a, b, c]

var aa = a
var bb = b
var cc = c
var dd = d

a = 11
b = 22
c.name = 'hello'
d[2]['age'] = 3

console.log(aa) // 1，因为aa是基本类型，不受之后的a重新赋值的影响
console.log(bb) // 2,理由同上
console.log(cc) //  Object {name: "hello", age: 3},因为对对象中的数据进行了更改
console.log(dd) //  [1,2，{name: 'hello', age: 2 }]，因为引用类型放在堆内存中，前面对对象d的操作已经改变了其存储在堆内存中的数据。
4.如下代码输出什么? 为什么
var a = 1
var c = { name: 'jirengu', age: 2 }

function f1(n){
  ++n
}
function f2(obj){
  ++obj.age
}

f1(a) 
f2(c) 
f1(c.age) 
console.log(a)  // 1,n是一个未定义的变量，运行时输出n会报错，实际f1这个函数未运行
console.log(c) // { name: 'jirengu', age: 3 }
5.过滤如下数组，只保留正数，直接在原数组上操作
var arr = [3,1,0,-1,-3,2,-5]
function filter(arr){
     for(var i = 0; i<arr.length;i++){
     if(arr[i] <= 0){
        arr.splice(i,1);
        i--;
     }
   }
 }
filter(arr)
console.log(arr) // [3,1,2]
6.过滤如下数组，只保留正数，原数组不变，生成新数组
var arr = [3,1,0,-1,-3,2,-5]
function filter(arr){
var newArr = []; 
var a = 0;
	for (var i=0; i<arr.length; i++) {
		if (arr[i] > 0 ) {
			newArr[a] = arr[i];
			a++;
		}
	}
	return newArr;
}
var arr2 = filter(arr)
console.log(arr2)
console.log(arr)
7 两种深拷贝的方式
深拷贝方式1
var obj = {
a = 1,
b = 2,
c : {
name:'saber',
sex: 'male'
}
}
function copy(obj){

var var newObj = { }
for ( var key in obj){
    if(obj.hasOwnProperty(key)){
        if(typeof obj[key] === 'number' || 
           typeof obj[key] === 'string' || 
           typeof obj[key] === 'boolen' || 
           typeof obj[key] === undefined || 
           typeof obj[key] === null || ){
               newObj[key] = obj [key]
           }else {
               newObj[key] = copy(obj[key])
           }
    }
}
return newObj
}

深拷贝方式2
JSON.stringify(obj)
JSON.parse(JSON.stringify(obj))
